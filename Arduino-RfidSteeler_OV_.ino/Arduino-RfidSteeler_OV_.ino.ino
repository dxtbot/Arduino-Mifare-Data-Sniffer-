/* Made by Dexterbot RFID Reader //
*/

#include <Adafruit_SSD1306.h>
#define OLED_Address 0x3C
Adafruit_SSD1306 oled(1);
#include <SPI.h>
#include <MFRC522.h>
#include <EEPROM.h>
#define SS_PIN 10
#define RST_PIN 9
MFRC522 rfid(SS_PIN, RST_PIN); // Instance of the class
MFRC522::MIFARE_Key key;
byte nuidPICC[4];
byte cardov ;
uint8_t MEM_STEP = 0 ;
uint8_t booter;
uint8_t checker;
static const unsigned char PROGMEM NSLOGO[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0xFF, 0xF8, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFE, 0x00, 0x1F, 0x80, 0x00,
  0x00, 0x03, 0xFF, 0xFF, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x0F, 0xC0, 0x00,
  0x00, 0x07, 0xFF, 0xFF, 0x80, 0x07, 0xE0, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x80, 0x03, 0xE0, 0x00,
  0x00, 0x1F, 0xFF, 0xFF, 0xC0, 0x03, 0xF0, 0x00, 0x00, 0x1F, 0x80, 0x07, 0xE0, 0x01, 0xF8, 0x00,
  0x00, 0x3F, 0x00, 0x07, 0xE0, 0x01, 0xF8, 0x00, 0x00, 0x3F, 0x00, 0x03, 0xF0, 0x00, 0xFC, 0x00,
  0x00, 0x7E, 0x00, 0x01, 0xF0, 0x00, 0x7C, 0x00, 0x00, 0x7C, 0x00, 0x01, 0xF8, 0x00, 0x7E, 0x00,
  0x00, 0xFC, 0x00, 0x00, 0xFC, 0x00, 0x3F, 0x00, 0x01, 0xF8, 0x00, 0x00, 0xFC, 0x00, 0x3F, 0x00,
  0x01, 0xFF, 0xFF, 0xC0, 0x7F, 0xFF, 0xFF, 0x80, 0x03, 0xFF, 0xFF, 0xE0, 0x7F, 0xFF, 0xFF, 0x80,
  0x03, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xC0, 0x07, 0xFF, 0xFF, 0xF8, 0x1F, 0xFF, 0xFF, 0xE0,
  0x07, 0xFF, 0xFF, 0xF8, 0x1F, 0xFF, 0xFF, 0xC0, 0x03, 0xFF, 0xFF, 0xFC, 0x0F, 0xFF, 0xFF, 0xC0,
  0x03, 0xFF, 0xFF, 0xFC, 0x07, 0xFF, 0xFF, 0x80, 0x01, 0xF8, 0x00, 0x7E, 0x00, 0x00, 0x3F, 0x00,
  0x00, 0xFC, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0xFC, 0x00, 0x3F, 0x00, 0x00, 0x7E, 0x00,
  0x00, 0x7E, 0x00, 0x1F, 0x80, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x0F, 0x80, 0x00, 0xFC, 0x00,
  0x00, 0x3F, 0x00, 0x0F, 0xC0, 0x00, 0xF8, 0x00, 0x00, 0x1F, 0x80, 0x07, 0xE0, 0x01, 0xF8, 0x00,
  0x00, 0x1F, 0x80, 0x07, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x03, 0xFF, 0xFF, 0xF0, 0x00,
  0x00, 0x0F, 0xC0, 0x01, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x07, 0xE0, 0x01, 0xFF, 0xFF, 0xC0, 0x00,
  0x00, 0x03, 0xF0, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x03, 0xF0, 0x00, 0xFF, 0xFF, 0x80, 0x00,
  0x00, 0x01, 0xF8, 0x00, 0x7F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const unsigned char PROGMEM chipkaart_logo [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x01, 0xFC, 0x00, 0x00, 0x01, 0xDE, 0x00, 0x00,
  0x03, 0x86, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x3F, 0x03, 0x03, 0xFC, 0x7F, 0x03, 0x07, 0xFE,
  0x7F, 0x03, 0x0F, 0xFE, 0x63, 0x06, 0x0C, 0x02, 0x41, 0x8E, 0x1C, 0x02, 0x41, 0xFE, 0x38, 0x02,
  0x40, 0xFC, 0x70, 0x02, 0x40, 0x70, 0x60, 0x02, 0x40, 0x00, 0xE0, 0x02, 0x40, 0x01, 0xC0, 0x02,
  0x40, 0x03, 0x80, 0x02, 0x40, 0x07, 0x00, 0x02, 0x40, 0x07, 0x0C, 0x02, 0x40, 0x0E, 0x3F, 0x02,
  0x40, 0x1C, 0x3F, 0x82, 0x40, 0x38, 0x71, 0x82, 0x40, 0x38, 0x61, 0xC2, 0x60, 0x70, 0xC0, 0xC6,
  0x7F, 0xE0, 0xC0, 0xFE, 0x3F, 0xC0, 0xC0, 0xFC, 0x00, 0x00, 0x60, 0xC0, 0x00, 0x00, 0x61, 0xC0,
  0x00, 0x00, 0x73, 0x80, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00
};

void setup() {
  oled.begin(SSD1306_SWITCHCAPVCC, OLED_Address);
  oled.clearDisplay();
  delay(100);
  Serial.begin(19200);
  checker = EEPROM.read(4);
  //Serial.println(checker);
  delay(1000);
  oled.setCursor(10, 40);
  oled.setTextColor(WHITE);
  oled.setTextSize(1);
  oled.print("MEM CHECK");
  for (int i = 0; checker >= 225; i++) {
    checker = (EEPROM.read(4 + MEM_STEP));
    MEM_STEP = MEM_STEP + 5;
    booter = booter + 1;
  }
  if (booter > 0) {
    Serial.print("Cards present in memory = ");
    Serial.println(booter - 1);
  }
  EEPROM.write(150, booter - 1);

  MEM_STEP = EEPROM.read(160);
  oled.display();
  delay(1000);
  oled.clearDisplay();
  oled.setTextColor(WHITE);
  oled.setTextSize(2);
  oled.setCursor(17, 18);
  oled.print("OVCracker");
  oled.setCursor(38, 40);
  oled.print("v1.1");
  oled.display();
  delay (1000);
  oled.clearDisplay();
  oled.setTextColor(WHITE);
  oled.setTextSize(2);
  oled.setCursor(15, 20);
  oled.print("made by");
  oled.setCursor(10, 40);
  oled.print("Dexterbot");
  oled.display();
  delay (1000);
  oled.clearDisplay();
  oled.setTextColor(WHITE);
  oled.setTextSize(1);
  oled.setCursor(12, 8);
  oled.print("SYsTEM OK ");
  oled.setTextSize(2);
  oled.setCursor(10, 40);
  oled.print("BOOTING...");
  oled.display();
  delay (2000);
  oled.clearDisplay();
  oled.setTextColor(WHITE);
  oled.setTextSize(1);
  oled.setCursor(24, 8);
  oled.print("! SCAN CARD ! ");
  oled.setCursor(10, 40);
  oled.print("LISTENING...");
  oled.drawBitmap(87, 30, chipkaart_logo, 32, 32, 1);
  oled.display();
  delay (1000);
  oled.clearDisplay();
  SPI.begin(); // Init SPI bus
  rfid.PCD_Init(); // Init MFRC522

  for (byte i = 0; i < 6; i++) {
    key.keyByte[i] = 0x00;   // SET YOUR KEY HERE , DEFAULT = 000000000000
  }

  Serial.println(F("Waiting for DXTreader Scan Card Please !"));
  // Serial.print(F("Using the following key:"));
  // printHex(key.keyByte, MFRC522::MF_KEY_SIZE);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void loop() {
  // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle.
  if ( ! rfid.PICC_IsNewCardPresent())
    return;
  // Verify if the NUID has been readed
  if ( ! rfid.PICC_ReadCardSerial())
    return;
  Serial.println("..........................");
  Serial.print(F("Card scanned : "));
  MFRC522::PICC_Type piccType = rfid.PICC_GetType(rfid.uid.sak);
  Serial.println(rfid.PICC_GetTypeName(piccType));
  cardov = (rfid.PICC_GetTypeName(piccType));
  // Check is the PICC of Classic MIFARE type
  if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI &&
      piccType != MFRC522::PICC_TYPE_MIFARE_1K &&
      piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
    Serial.println(F("Your tag is not of type MIFARE"));
    return;
  }
  if (rfid.uid.uidByte[0] != nuidPICC[0] ||
      rfid.uid.uidByte[1] != nuidPICC[1] ||
      rfid.uid.uidByte[2] != nuidPICC[2] ||
      rfid.uid.uidByte[3] != nuidPICC[3] ) {
    //Serial.println(F("A new card has been detected."));
    oled.clearDisplay();
    oled.drawBitmap(35, 2, NSLOGO, 64, 64, 1);
    oled.display();
    delay(800);
    // Store NUID into nuidPICC array
    for (byte i = 0; i < 4; i++) {
      nuidPICC[i] = rfid.uid.uidByte[i];
    }
    Serial.print(F("The Card nr = "));
    // Serial.print(F("In hex: "));
    printHex(rfid.uid.uidByte, rfid.uid.size);
    Serial.println();
    //  Serial.print(F("In dec: "));
    printDec(rfid.uid.uidByte, rfid.uid.size);
    // Serial.println();
    oled.clearDisplay();
    oled.setTextColor(WHITE);
    oled.setTextSize(1);
    oled.setCursor(24, 8);
    oled.print("! SCAN CARD ! ");
    oled.setCursor(10, 40);
    oled.print("LISTENING...");
    oled.drawBitmap(87, 30, chipkaart_logo, 32, 32, 1);
    oled.display();
  }
  else Serial.println(F("! Same Card !"));

  // Halt PICC
  rfid.PICC_HaltA();

  // Stop encryption on PCD
  rfid.PCD_StopCrypto1();
}


/**
   Helper routine to dump a byte array as hex values to Serial.
*/
void printHex(byte *buffer, byte bufferSize) {
  for (byte i = 0; i < bufferSize; i++) {
    Serial.print(buffer[i] < 0x10 ? " 0" : " ");
    Serial.print(buffer[i], HEX);

  }
}

void printDec(byte *buffer, byte bufferSize) {
  oled.clearDisplay();
  oled.setTextColor(WHITE);
  oled.setTextSize(1);
  oled.setCursor(10, 8);
  oled.print("! Card UID Found !");
  oled.setCursor(34, 32);
  delay(100);
  if (cardov != 228 && cardov != 239 && cardov != 240)oled.print("UNKNOWN CARD");
  if (cardov == 240)oled.print("MF MINICARD");
  if (cardov == 239)oled.print("MF 1K CARD");
  if (cardov == 228)oled.print("MF 4K CARD");
  oled.setTextSize(2);
  oled.setCursor(13, 47);
  oled.print(buffer[0], HEX);
  oled.setCursor(40, 47);
  oled.print(buffer[1], HEX);
  oled.setCursor(67, 47);
  oled.print(buffer[2], HEX);
  oled.setCursor(94, 47);
  oled.print(buffer[3], HEX);
  oled.display();
  delay(1500);
  oled.clearDisplay();
  EEPROM.write(0 + MEM_STEP, buffer[0]);
  EEPROM.write(1 + MEM_STEP, buffer[1]);
  EEPROM.write(2 + MEM_STEP, buffer[2]);
  EEPROM.write(3 + MEM_STEP, buffer[3]);
  EEPROM.write(4 + MEM_STEP, cardov);
  MEM_STEP = MEM_STEP + 5;
  EEPROM.write(160, MEM_STEP);
  //Serial.print("MEM_STEP = ");
  // Serial.println(MEM_STEP);
  if (MEM_STEP == EEPROM.length()) {
    oled.clearDisplay();
    oled.setTextColor(WHITE);
    oled.setTextSize(1);
    oled.setCursor(10, 8);
    Serial.println(" ");
    Serial.print("! Card MEM full !");
    oled.print("! Card MEM full !");
    oled.setCursor(34, 32);
    return;
  }
}
